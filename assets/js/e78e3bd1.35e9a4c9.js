"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[648],{3676:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>d,contentTitle:()=>o,default:()=>m,frontMatter:()=>s,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"Patrones_de_diseno_de_comportamiento/Strategy","title":"Strategy","description":"----------","source":"@site/docs/Patrones_de_diseno_de_comportamiento/Strategy.md","sourceDirName":"Patrones_de_diseno_de_comportamiento","slug":"/Patrones_de_diseno_de_comportamiento/Strategy","permalink":"/Documentacion_PDC/docs/Patrones_de_diseno_de_comportamiento/Strategy","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Patrones_de_diseno_de_comportamiento/Strategy.md","tags":[],"version":"current","sidebarPosition":9,"frontMatter":{"sidebar_position":9},"sidebar":"tutorialSidebar","previous":{"title":"State","permalink":"/Documentacion_PDC/docs/Patrones_de_diseno_de_comportamiento/State"},"next":{"title":"Template Method","permalink":"/Documentacion_PDC/docs/Patrones_de_diseno_de_comportamiento/Template-Method"}}');var r=t(4848),i=t(8453);const s={sidebar_position:9},o="Strategy",d={},c=[{value:"Definici\xf3n",id:"definici\xf3n",level:2},{value:"Proposito",id:"proposito",level:2},{value:"Caracteristicas principales",id:"caracteristicas-principales",level:2},{value:"Ventajas y Desventajas",id:"ventajas-y-desventajas",level:2},{value:"Ejemplo de codigo en Python",id:"ejemplo-de-codigo-en-python",level:2},{value:"Analog\xeda",id:"analog\xeda",level:2}];function l(e){const a={code:"code",h1:"h1",h2:"h2",header:"header",hr:"hr",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(a.header,{children:(0,r.jsx)(a.h1,{id:"strategy",children:"Strategy"})}),"\n",(0,r.jsx)(a.hr,{}),"\n",(0,r.jsx)(a.h2,{id:"definici\xf3n",children:"Definici\xf3n"}),"\n",(0,r.jsx)(a.p,{children:"El patr\xf3n Estrategia (Strategy) es un patr\xf3n de dise\xf1o para el desarrollo de software. Se clasifica como patr\xf3n de comportamiento porque determina c\xf3mo se debe realizar el intercambio de mensajes entre diferentes objetos para resolver una tarea. El patr\xf3n estrategia permite mantener un conjunto de algoritmos de entre los cuales el objeto cliente puede elegir aquel que le conviene e intercambiarlo din\xe1micamente seg\xfan sus necesidades."}),"\n",(0,r.jsx)(a.p,{children:(0,r.jsx)(a.img,{src:"https://refactoring.guru/images/patterns/diagrams/strategy/structure.png?id=c6aa910c94960f35d100bfca02810ea1",alt:"Patron strategy"})}),"\n",(0,r.jsx)(a.hr,{}),"\n",(0,r.jsx)(a.h2,{id:"proposito",children:"Proposito"}),"\n",(0,r.jsxs)(a.p,{children:[(0,r.jsx)(a.strong,{children:"Strategy"})," es un patr\xf3n de dise\xf1o de comportamiento que te permite definir una familia de algoritmos, colocar cada uno de ellos en una clase separada y hacer sus objetos intercambiables."]}),"\n",(0,r.jsx)(a.p,{children:(0,r.jsx)(a.img,{src:"https://refactoring.guru/images/patterns/content/strategy/strategy.png?id=379bfba335380500375881a3da6507e0",alt:"Strategy_image"})}),"\n",(0,r.jsx)(a.hr,{}),"\n",(0,r.jsx)(a.h2,{id:"caracteristicas-principales",children:"Caracteristicas principales"}),"\n",(0,r.jsxs)(a.ul,{children:["\n",(0,r.jsx)(a.li,{children:(0,r.jsx)(a.strong,{children:"Encapsulamiento de algoritmos:"})}),"\n"]}),"\n",(0,r.jsx)(a.p,{children:"Cada estrategia (algoritmo) se implementa en una clase separada que sigue una misma interfaz com\xfan.\r\nEsto facilita agregar nuevas estrategias sin modificar el c\xf3digo existente."}),"\n",(0,r.jsxs)(a.ul,{children:["\n",(0,r.jsx)(a.li,{children:(0,r.jsx)(a.strong,{children:"Intercambiabilidad:"})}),"\n"]}),"\n",(0,r.jsx)(a.p,{children:"Los algoritmos pueden intercambiarse din\xe1micamente en tiempo de ejecuci\xf3n.\r\nEsto se logra al asignar un objeto de estrategia diferente al contexto que las utiliza."}),"\n",(0,r.jsxs)(a.ul,{children:["\n",(0,r.jsx)(a.li,{children:(0,r.jsx)(a.strong,{children:"Separaci\xf3n del comportamiento y el contexto:"})}),"\n"]}),"\n",(0,r.jsx)(a.p,{children:"El contexto (la clase principal) delega la ejecuci\xf3n del comportamiento a una estrategia espec\xedfica.\r\nEsto reduce la complejidad del contexto y lo hace m\xe1s f\xe1cil de mantener."}),"\n",(0,r.jsxs)(a.ul,{children:["\n",(0,r.jsx)(a.li,{children:(0,r.jsx)(a.strong,{children:"Uso de composici\xf3n sobre herencia:"})}),"\n"]}),"\n",(0,r.jsx)(a.p,{children:"En lugar de usar herencia para modificar o agregar comportamientos, Strategy usa la composici\xf3n, delegando el comportamiento a un objeto de estrategia."}),"\n",(0,r.jsxs)(a.ul,{children:["\n",(0,r.jsx)(a.li,{children:(0,r.jsx)(a.strong,{children:"Cumple con el Principio Abierto-Cerrado:"})}),"\n"]}),"\n",(0,r.jsx)(a.p,{children:"Las estrategias nuevas se pueden agregar extendiendo el sistema, sin necesidad de modificar el c\xf3digo del contexto."}),"\n",(0,r.jsxs)(a.ul,{children:["\n",(0,r.jsx)(a.li,{children:(0,r.jsx)(a.strong,{children:"Fomenta la cohesi\xf3n:"})}),"\n"]}),"\n",(0,r.jsx)(a.p,{children:"Cada estrategia tiene un prop\xf3sito bien definido, lo que mejora la claridad y la modularidad del c\xf3digo."}),"\n",(0,r.jsx)(a.hr,{}),"\n",(0,r.jsx)(a.h2,{id:"ventajas-y-desventajas",children:"Ventajas y Desventajas"}),"\n",(0,r.jsxs)(a.table,{children:[(0,r.jsx)(a.thead,{children:(0,r.jsxs)(a.tr,{children:[(0,r.jsx)(a.th,{children:"Ventajas"}),(0,r.jsx)(a.th,{children:"Desventajas"})]})}),(0,r.jsxs)(a.tbody,{children:[(0,r.jsxs)(a.tr,{children:[(0,r.jsx)(a.td,{children:"Permite agregar nuevas estrategias sin modificar el c\xf3digo cliente."}),(0,r.jsx)(a.td,{children:"Puede aumentar la complejidad si se crean demasiadas estrategias."})]}),(0,r.jsxs)(a.tr,{children:[(0,r.jsx)(a.td,{children:"Promueve el cumplimiento del principio SOLID, especialmente el abierto/cerrado."}),(0,r.jsx)(a.td,{children:"Requiere que el cliente tenga conocimiento de las estrategias disponibles."})]}),(0,r.jsxs)(a.tr,{children:[(0,r.jsx)(a.td,{children:"Facilita pruebas unitarias al permitir el uso de estrategias independientes."}),(0,r.jsx)(a.td,{children:"Puede implicar una sobrecarga de memoria y procesamiento al manejar muchas instancias de estrategias."})]}),(0,r.jsxs)(a.tr,{children:[(0,r.jsx)(a.td,{children:"Permite elegir la estrategia en tiempo de ejecuci\xf3n."}),(0,r.jsx)(a.td,{children:"Si no se implementa correctamente, puede ser confuso para desarrolladores nuevos en el proyecto."})]})]})]}),"\n",(0,r.jsx)(a.hr,{}),"\n",(0,r.jsx)(a.h2,{id:"ejemplo-de-codigo-en-python",children:"Ejemplo de codigo en Python"}),"\n",(0,r.jsx)(a.p,{children:"El patr\xf3n Strategy permite definir un conjunto de algoritmos intercambiables y encapsular cada uno dentro de su propia clase. En el ejemplo, las estrategias representan m\xe9todos de pago diferentes (tarjeta de cr\xe9dito y PayPal). El contexto maneja la estrategia seleccionada y delega la ejecuci\xf3n del pago. Esto permite cambiar la estrategia sin modificar el c\xf3digo del contexto."}),"\n",(0,r.jsx)(a.p,{children:"Clave: Las estrategias son independientes y se intercambian din\xe1micamente seg\xfan las necesidades."}),"\n",(0,r.jsx)(a.pre,{children:(0,r.jsx)(a.code,{className:"language-python",children:'from abc import ABC, abstractmethod\r\n\r\n# Interfaz de estrategia\r\nclass PaymentStrategy(ABC):\r\n    @abstractmethod\r\n    def pay(self, amount):\r\n        pass\r\n\r\n# Estrategias concretas\r\nclass CreditCardPayment(PaymentStrategy):\r\n    def pay(self, amount):\r\n        return f"Paid {amount} using Credit Card."\r\n\r\nclass PayPalPayment(PaymentStrategy):\r\n    def pay(self, amount):\r\n        return f"Paid {amount} using PayPal."\r\n\r\nclass BitcoinPayment(PaymentStrategy):\r\n    def pay(self, amount):\r\n        return f"Paid {amount} using Bitcoin."\r\n\r\n# Contexto que utiliza las estrategias\r\nclass ShoppingCart:\r\n    def __init__(self, payment_strategy: PaymentStrategy):\r\n        self.payment_strategy = payment_strategy\r\n\r\n    def checkout(self, amount):\r\n        return self.payment_strategy.pay(amount)\r\n\r\n# Uso del patr\xf3n\r\ncart1 = ShoppingCart(CreditCardPayment())\r\nprint(cart1.checkout(100))  # Output: Paid 100 using Credit Card.\r\n\r\ncart2 = ShoppingCart(PayPalPayment())\r\nprint(cart2.checkout(250))  # Output: Paid 250 using PayPal.\r\n\r\ncart3 = ShoppingCart(BitcoinPayment())\r\nprint(cart3.checkout(500))  # Output: Paid 500 using Bitcoin.\r\n\n'})}),"\n",(0,r.jsx)(a.hr,{}),"\n",(0,r.jsx)(a.h2,{id:"analog\xeda",children:"Analog\xeda"}),"\n",(0,r.jsx)(a.p,{children:"Imagina que tienes que llegar al aeropuerto. Puedes tomar el autob\xfas, pedir un taxi o ir en bicicleta. \xc9stas son tus estrategias de transporte. Puedes elegir una de las estrategias, dependiendo de factores como el presupuesto o los l\xedmites de tiempo."}),"\n",(0,r.jsx)(a.p,{children:(0,r.jsx)(a.img,{src:"https://refactoring.guru/images/patterns/content/strategy/strategy-comic-1-es.png?id=1cf442d8c2d5d78f214499bb72dfdc72",alt:"imagen de analog\xeda: Strategy"})})]})}function m(e={}){const{wrapper:a}={...(0,i.R)(),...e.components};return a?(0,r.jsx)(a,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},8453:(e,a,t)=>{t.d(a,{R:()=>s,x:()=>o});var n=t(6540);const r={},i=n.createContext(r);function s(e){const a=n.useContext(i);return n.useMemo((function(){return"function"==typeof e?e(a):{...a,...e}}),[a,e])}function o(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),n.createElement(i.Provider,{value:a},e.children)}}}]);